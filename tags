!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BoltzmannProb	utility.cc	/^double BoltzmannProb(const double &diffE, const double &temperature) {$/;"	f
CVRP	cvrp.h	/^      CVRP(int numOfGenes, int numOfGenerations, double crossoverRate, double mutationRate, double temperature): numOfGenes_(numOfGenes), numOfGenerations_(numOfGenerations), crossoverRate_(crossoverRate), mutationRate_(mutationRate), temperature_(temperature), solutionCounter_(0), lastSolution_(0) {};$/;"	f	class:CVRP
CVRP	cvrp.h	/^class CVRP {$/;"	c
DEPOT	gene.cc	22;"	d	file:
Gene	gene.h	/^    Gene() {}$/;"	f	class:Gene
Gene	gene.h	/^    Gene(const Gene &gene): nodes_(gene.nodes_) {}$/;"	f	class:Gene
Gene	gene.h	/^    Gene(const Gene *gp): nodes_(gp->nodes_) {}$/;"	f	class:Gene
Gene	gene.h	/^    Gene(const vector<Node> &nodes): nodes_(nodes) {}$/;"	f	class:Gene
Gene	gene.h	/^class Gene {$/;"	c
MIN	gene.cc	21;"	d	file:
MIN	node.cc	20;"	d	file:
Node	node.h	/^    Node(const Node &node): tag_(node.tag_) {}$/;"	f	class:Node
Node	node.h	/^    Node(const int tag): tag_(tag) {}$/;"	f	class:Node
Node	node.h	/^class Node {$/;"	c
PI	node.cc	21;"	d	file:
PI	utility.cc	22;"	d	file:
Rbx	gene.cc	/^Gene Gene::Rbx(const Gene &parent, const double &crossoverRate) {$/;"	f	class:Gene
_CVRP_CC_	cvrp.cc	10;"	d	file:
_CVRP_H_	cvrp.h	2;"	d
_GENE_CC_	gene.cc	10;"	d	file:
_GENE_H_	gene.h	2;"	d
_NODE_CC_	node.cc	10;"	d	file:
_NODE_H_	node.h	2;"	d
_UTILITY_CC_	utility.cc	10;"	d	file:
_UTILITY_H_	utility.h	2;"	d
acceptGene	gene.cc	/^void Gene::acceptGene(Gene &gene, const double &temperature) {$/;"	f	class:Gene
angle	node.cc	/^double Node::angle() const { return angleTable_[0][this->tag() - 1]; }$/;"	f	class:Node
angleTable_	node.cc	/^vector< vector<double> > Node::angleTable_, Node::distanceTable_;$/;"	m	class:Node	file:
angleTable_	node.h	/^    static vector< vector<double> > angleTable_, distanceTable_;$/;"	m	class:Node
arctan	utility.cc	/^double arctan(const int &dx, const int &dy) {$/;"	f
capacity_	gene.cc	/^int Gene::capacity_ = 0;$/;"	m	class:Gene	file:
capacity_	gene.h	/^    static int capacity_, dimension_;$/;"	m	class:Gene
chop	gene.cc	/^void Gene::chop() {$/;"	f	class:Gene
contain	utility.h	/^bool contain(const vector<T> &vec, const T &elem) {$/;"	f
cost	gene.cc	/^double Gene::cost() const {$/;"	f	class:Gene
crossover	cvrp.cc	/^void CVRP::crossover(const double &crossoverRate) {$/;"	f	class:CVRP
crossoverRate_	cvrp.h	/^    double lastSolution_, crossoverRate_, mutationRate_, temperature_;$/;"	m	class:CVRP
cvrp.cc	cvrp.cc	1;"	F
cvrp.h	cvrp.h	1;"	F
demand	node.cc	/^int Node::demand() const { return demandList_[this->tag() - 1]; }$/;"	f	class:Node
demandList_	node.cc	/^vector<int> Node::demandList_;$/;"	m	class:Node	file:
demandList_	node.h	/^    static vector<int> demandList_;$/;"	m	class:Node
dimension_	cvrp.cc	/^int CVRP::dimension_ = 0;$/;"	m	class:CVRP	file:
dimension_	cvrp.h	/^    static int dimension_; $/;"	m	class:CVRP
dimension_	gene.cc	/^int Gene::dimension_ = 0;$/;"	m	class:Gene	file:
dimension_	gene.h	/^    static int capacity_, dimension_;$/;"	m	class:Gene
distanceTable_	node.cc	/^vector< vector<double> > Node::angleTable_, Node::distanceTable_;$/;"	m	class:Node	file:
distanceTable_	node.h	/^    static vector< vector<double> > angleTable_, distanceTable_;$/;"	m	class:Node
evolve	cvrp.cc	/^void CVRP::evolve() {$/;"	f	class:CVRP
extract_int	utility.cc	/^int extract_int(const string &term) {$/;"	f
extract_ints	utility.cc	/^vector<int> extract_ints(const string &term) {$/;"	f
gene.cc	gene.cc	1;"	F
gene.h	gene.h	1;"	F
generateGenes	cvrp.cc	/^void CVRP::generateGenes() {$/;"	f	class:CVRP
generateRandom	utility.cc	/^double generateRandom(int lower, int upper) {$/;"	f
genes_	cvrp.h	/^    vector<Gene> genes_;$/;"	m	class:CVRP
initialize	node.cc	/^vector<int> Node::initialize(const char *fileName) {$/;"	f	class:Node
kB	utility.cc	23;"	d	file:
lastSolution_	cvrp.h	/^    double lastSolution_, crossoverRate_, mutationRate_, temperature_;$/;"	m	class:CVRP
main	main.cc	/^int main(int argc, char** argv){$/;"	f
main.cc	main.cc	1;"	F
mutationRate_	cvrp.h	/^    double lastSolution_, crossoverRate_, mutationRate_, temperature_;$/;"	m	class:CVRP
node.cc	node.cc	1;"	F
node.h	node.h	1;"	F
nodes_	gene.h	/^    vector<Node> nodes_;$/;"	m	class:Gene
numOfGenerations_	cvrp.h	/^    int numOfGenes_, numOfGenerations_, solutionCounter_;$/;"	m	class:CVRP
numOfGenes_	cvrp.h	/^    int numOfGenes_, numOfGenerations_, solutionCounter_;$/;"	m	class:CVRP
operator !=	node.cc	/^bool Node::operator!=(const Node &node) const { return !((*this) == node); }$/;"	f	class:Node
operator ()	node.cc	/^double Node::operator()(const Node &node) const {$/;"	f	class:Node
operator <	node.cc	/^bool Node::operator<(const Node &node) const { return this->tag() < node.tag(); }$/;"	f	class:Node
operator =	gene.cc	/^Gene &Gene::operator=(const Gene &gene) {$/;"	f	class:Gene
operator =	node.cc	/^Node& Node::operator=(const Node &node) { this->tag_ = node.tag_; return *this; }$/;"	f	class:Node
operator ==	node.cc	/^bool Node::operator==(const Node &node) const { return this->tag() == node.tag(); }$/;"	f	class:Node
optMutation	gene.cc	/^void Gene::optMutation(const double &mutationRate) {$/;"	f	class:Gene
print	gene.cc	/^void Gene::print() const {$/;"	f	class:Gene
randomPos	gene.cc	/^vector<int> Gene::randomPos() {$/;"	f	class:Gene
readFile	utility.cc	/^vector< vector<int> > readFile(const char *path) {$/;"	f
selectByCost	cvrp.cc	/^vector<int> CVRP::selectByCost() {$/;"	f	class:CVRP
sequentialMutate	gene.cc	/^void Gene::sequentialMutate(const double &mutationRate, const double &temperature) {$/;"	f	class:Gene
setDimension	cvrp.cc	/^void CVRP::setDimension(const int &dimension) { dimension_ = dimension; }$/;"	f	class:CVRP
setDimensionAndCapacity	gene.cc	/^int Gene::setDimensionAndCapacity(const vector<int> &dimensionAndCapacity) {$/;"	f	class:Gene
solutionCounter_	cvrp.h	/^    int numOfGenes_, numOfGenerations_, solutionCounter_;$/;"	m	class:CVRP
solve	cvrp.cc	/^void CVRP::solve() {$/;"	f	class:CVRP
sortByCost	cvrp.cc	/^void CVRP::sortByCost() { sort(genes_.begin(), genes_.end(), [=](const Gene &i, const Gene &j){ return i.cost() < j.cost(); }); }$/;"	f	class:CVRP
start-cvrp	start-cvrp	1;"	F
tag	node.cc	/^int Node::tag() const { return tag_; }$/;"	f	class:Node
tag_	node.h	/^    int tag_;$/;"	m	class:Node
temperature_	cvrp.h	/^    double lastSolution_, crossoverRate_, mutationRate_, temperature_;$/;"	m	class:CVRP
utility.cc	utility.cc	1;"	F
utility.h	utility.h	1;"	F
validate	gene.cc	/^bool Gene::validate() {$/;"	f	class:Gene
vectorCost	gene.cc	/^double vectorCost(const vector<Node> &nodes) {$/;"	f
